@page "/tool/{route}"

@using BigBang1112.Gbx.Client.Models.UtilImport;
@using GBX.NET;
@using GBX.NET.Attributes;
@using System.Reflection;
@using GbxToolAPI;
@using System.Text;
@using System.Text.Json;

@inject IToolManager ToolManager
@inject NavigationManager NavMgr
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage

@if (ToolFactory is null)
{
    <PageTitle>Tool not found - Gbx Web Tools</PageTitle>
    <div>Tool not found.</div>

    return;
}

<PageTitle>@ToolFactory.Name - Tool - Gbx Web Tools</PageTitle>

@{
    var githubRepo = ToolFactory.ToolType.GetCustomAttribute<ToolGitHubAttribute>()?.Repository;
    var ctors = ToolFactory.ToolType.GetConstructors();
}

<div class="util-background">

    @if (ToolFactory.ComponentType is null)
    {
        <div class="util-container">

        @if (string.Equals(Produce, "selected", StringComparison.OrdinalIgnoreCase))
        {
            if (gbxSelection.Count == 0)
            {
                <h2>No files have been selected</h2>
            }
            else if (ToolFactory.HasOutput)
            {
                <ToolProduceReport ToolFactory="ToolFactory" GbxSelection="gbxSelection"></ToolProduceReport>
            }
            else
            {
                <h2>This tool doesn't support producing</h2>
            }
        }
        else
        {
            <UtilImport Name="@ToolFactory.Name"
                        Route="@ToolFactory.Route"
                        ImportTypes="ImportTypes"
                        Produces="Outputs.Count > 0"
                        Configs="Configs"
                        GbxSelection="gbxSelection">
                <div class="basic-info">
                    <div class="description darker-bg">
                        @ToolFactory.Description
                    </div>
                    <div class="rectangle">
                        @if (githubRepo is not null)
                        {
                            <a href="https://github.com/@githubRepo/releases" class="button" target="_blank">Download tool as executable</a>
                        }
                    </div>
                </div>
            </UtilImport>
        }

        </div>
    }
    else
    {
        <DynamicComponent Type="ToolFactory.ComponentType"></DynamicComponent>
    }

</div>

<div class="semi-overlay">
    
</div>

@code {
    private HashSet<GbxModel> gbxSelection = new();

    [Parameter]
    public string? Route { get; set; }

    public IToolFactory? ToolFactory { get; set; }
    public IEnumerable<UtilImportType> ImportTypes { get; set; } = Enumerable.Empty<UtilImportType>();
    public List<Type> Outputs { get; set; } = new();
    public Dictionary<string, Config> Configs { get; set; } = new();

    [Parameter]
    [SupplyParameterFromQuery]
    public string? Produce { get; set; }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        await base.SetParametersAsync(parameters);
    }

    protected override async Task OnParametersSetAsync()
    {
        if (Route is null)
        {
            return;
        }

        if (ToolFactory is not null)
        {
            return;
        }

        ToolFactory = ToolManager.GetToolFactoryByRoute(Route);

        if (ToolFactory is null)
        {
            return;
        }

        ImportTypes = ToolFactory.ToolType
            .GetConstructors()
            .Select(UtilImportType.FromConstructor)
            .ToList();

        Outputs = new();
        Configs = new();

        // This is a bit weird for inheritance and repetition and should be reworked
        var configType = default(Type);

        foreach (var iface in ToolFactory.ToolType.GetInterfaces())
        {
            if (iface.IsGenericType)
            {
                var def = iface.GetGenericTypeDefinition();

                if (def == typeof(IHasOutput<>))
                {
                    Outputs.Add(iface.GetGenericArguments()[0]);
                }
                else if (def == typeof(IConfigurable<>))
                {
                    configType = iface.GetGenericArguments()[0];
                }
            }
        }

        if (configType is null)
        {
            return;
        }

        var configList = await LocalStorage.GetItemAsync<Dictionary<string, JsonDocument>>($"Tool:{Route}:Config");

        if (configList is null || configList.Count == 0 || !configList.ContainsKey("Default"))
        {
            Configs.Add("Default", (Config)Activator.CreateInstance(configType)!);
        }
        
        if (configList is not null)
        {
            foreach (var config in configList)
            {
                Configs.Add(config.Key, (Config)JsonSerializer.Deserialize(config.Value, configType, Json.DefaultOptions)!);
            }
        }
    }

    private Dictionary<GbxModel, ITool> gbxModelLinkToTool = new();

    private void OnGbxSelectionChanged()
    {
        
    }
}
